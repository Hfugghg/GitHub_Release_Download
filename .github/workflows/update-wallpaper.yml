# .github/workflows/update-wallpaper.yml

name: Update Wallpaper Gallery

on:
  schedule:
    # 每小时运行一次
    - cron: '0 * * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-gallery:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # <--- 变更点 1: 获取完整历史
          # amend 操作需要基于上一个 commit，因此不能使用默认的浅克隆 (fetch-depth: 1)
          fetch-depth: 0

      - name: Update Wallpaper Gallery
        id: update_gallery
        run: |
          # --- 配置 ---
          MAX_FILES_PER_FOLDER=100
          PAGES_TO_PROCESS=3
          DUPLICATE_THRESHOLD=0.7

          # --- 初始化 ---
          mkdir -p assets/landscape assets/portrait
          touch assets/landscape/meta.json assets/portrait/meta.json
          EXISTING_IDS=$(jq -s '(.[0].data // []) + (.[1].data // []) | .[] .id' assets/landscape/meta.json assets/portrait/meta.json)
          
          # --- 数据获取和过滤 ---
          echo "开始获取和过滤新的壁纸..."
          NEW_IMAGES_JSON="[]"

          LAST_PAGE=$(curl -s "https://wallhaven.cc/api/v1/search?q=anime+girls&categories=010&sorting=toplist&topRange=1M&purity=100" | jq '.meta.last_page')
          if [[ -z "$LAST_PAGE" || "$LAST_PAGE" == "null" || "$LAST_PAGE" -lt 1 ]]; then
            echo "错误：无法获取有效的总页数。跳过本次更新。"
            exit 0
          fi
          echo "壁纸总页数 (toplist/1M): $LAST_PAGE"
          
          for i in $(seq 1 $PAGES_TO_PROCESS); do
            MIN_PAGE=$LAST_PAGE
            for _ in $(seq 1 6); do
              CURRENT_RANDOM_PAGE=$(( RANDOM % LAST_PAGE + 1 ))
              if [ "$CURRENT_RANDOM_PAGE" -lt "$MIN_PAGE" ]; then
                MIN_PAGE="$CURRENT_RANDOM_PAGE"
              fi
            done
            RANDOM_PAGE="$MIN_PAGE"
          
            echo "正在处理第 ${i}/${PAGES_TO_PROCESS} 页 (API Page: ${RANDOM_PAGE})..."
          
            # [变更 2] 将热门列表时间范围从 1y 改为 6M
            API_RESPONSE=$(curl -s "https://wallhaven.cc/api/v1/search?q=anime+girls&categories=010&sorting=toplist&topRange=6M&purity=100&page=${RANDOM_PAGE}")
            PAGE_IMAGES=$(echo "$API_RESPONSE" | jq -c '.data[]')
          
            if [[ -z "$PAGE_IMAGES" ]]; then continue; fi
          
            TOTAL_ON_PAGE=$(echo "$PAGE_IMAGES" | wc -l)
            if [ "$TOTAL_ON_PAGE" -eq 0 ]; then continue; fi
          
            FRESH_IMAGES_ON_PAGE="[]"

            while read -r image_json; do
              IMAGE_ID=$(echo "$image_json" | jq -r '.id')
              if echo "$EXISTING_IDS" | grep -q "\"$IMAGE_ID\""; then
                # 如果图片已存在，则跳过此图片
                continue
              else
                # 如果是新图片，则添加到本页的新图片列表中
                FRESH_IMAGES_ON_PAGE=$(echo "$FRESH_IMAGES_ON_PAGE" | jq --argjson img "$image_json" '. + [$img]')
              fi
            done <<< "$PAGE_IMAGES"

            # [变更 1] 移除重复率检查逻辑。
            # 现在无论重复图片有多少，只要有新图片就会被处理。
            # DUPLICATE_RATE=$(echo "scale=2; $DUPLICATES_ON_PAGE / $TOTAL_ON_PAGE" | bc)
            # if (( $(echo "$DUPLICATE_RATE > $DUPLICATE_THRESHOLD" | bc -l) )); then
            #   echo "警告：重复率 (${DUPLICATE_RATE}) 过高，放弃处理此页。"
            #   continue
            # fi

            # 将本次找到的新图片ID，立刻加入到EXISTING_IDS中，防止同一次运行中重复添加
            FRESH_IDS=$(echo "$FRESH_IMAGES_ON_PAGE" | jq -r '.[] .id')
            EXISTING_IDS="${EXISTING_IDS}\n${FRESH_IDS}"

            NEW_IMAGES_JSON=$(echo "$NEW_IMAGES_JSON" | jq --argjson fresh "$FRESH_IMAGES_ON_PAGE" '. + $fresh')
            echo "从本页成功添加 $(echo "$FRESH_IMAGES_ON_PAGE" | jq 'length') 张新图。"
          done

          if [[ $(echo "$NEW_IMAGES_JSON" | jq 'length') -eq 0 ]]; then
            echo "经过筛选，没有发现任何新的壁纸，本次任务结束。"
            exit 0
          fi
          
          # --- 处理、排序和下载 ---
          echo "开始处理和下载 $(echo "$NEW_IMAGES_JSON" | jq 'length') 张新壁纸..."
          # 采用更稳健的方式处理元数据
          # 先读取旧的元数据
          OLD_LANDSCAPE_META=$(jq '.data // []' assets/landscape/meta.json)
          OLD_PORTRAIT_META=$(jq '.data // []' assets/portrait/meta.json)
          # 将新的元数据收集到临时变量中
          NEW_LANDSCAPE_ENTRIES="[]"
          NEW_PORTRAIT_ENTRIES="[]"

          while read -r image_json; do
            ID=$(echo "$image_json" | jq -r '.id')
            PATH_URL=$(echo "$image_json" | jq -r '.path')
            SOURCE_URL=$(echo "$image_json" | jq -r '.source')
            RATIO=$(echo "$image_json" | jq -r '.ratio | tonumber')
            EXTENSION="${PATH_URL##*.}"
            FILENAME="${ID}.${EXTENSION}"
            TIMESTAMP=$(date --iso-8601=seconds)

            NEW_META_ENTRY=$(jq -n --arg id "$ID" --arg source "$SOURCE_URL" --arg ts "$TIMESTAMP" \
              '{id: $id, source: $source, added_at: $ts}')

            if (( $(echo "$RATIO >= 1.0" | bc -l) )); then
              echo "下载横屏图片: ${FILENAME}"
              curl -s -L -o "assets/landscape/${FILENAME}" "$PATH_URL"
              NEW_LANDSCAPE_ENTRIES=$(echo "$NEW_LANDSCAPE_ENTRIES" | jq --argjson entry "$NEW_META_ENTRY" '. + [$entry]')
            else
              echo "下载竖屏图片: ${FILENAME}"
              curl -s -L -o "assets/portrait/${FILENAME}" "$PATH_URL"
              NEW_PORTRAIT_ENTRIES=$(echo "$NEW_PORTRAIT_ENTRIES" | jq --argjson entry "$NEW_META_ENTRY" '. + [$entry]')
            fi
          done < <(echo "$NEW_IMAGES_JSON" | jq -c '.[]')

          # 下载和分类完成后，一次性合并新旧元数据
          LANDSCAPE_META=$(jq -s '.[0] + .[1]' <(echo "$OLD_LANDSCAPE_META") <(echo "$NEW_LANDSCAPE_ENTRIES"))
          PORTRAIT_META=$(jq -s '.[0] + .[1]' <(echo "$OLD_PORTRAIT_META") <(echo "$NEW_PORTRAIT_ENTRIES"))

          # --- 清理旧文件 (FIFO) ---
          echo "开始清理旧文件以维持数量上限..."
          TOTAL_LANDSCAPE=$(echo "$LANDSCAPE_META" | jq 'length')
          if [ "$TOTAL_LANDSCAPE" -gt "$MAX_FILES_PER_FOLDER" ]; then
            NUM_TO_DELETE=$((TOTAL_LANDSCAPE - MAX_FILES_PER_FOLDER))
            echo "横屏文件夹需要删除 ${NUM_TO_DELETE} 个最老的文件。"
            TO_DELETE=$(echo "$LANDSCAPE_META" | jq -c ".[0:${NUM_TO_DELETE}] | .[]")
            while read -r meta_entry; do
              ID_TO_DELETE=$(echo "$meta_entry" | jq -r '.id')
              find assets/landscape -name "${ID_TO_DELETE}.*" -exec rm {} \;
              echo "已删除旧文件: ${ID_TO_DELETE}.*"
            done <<< "$TO_DELETE"
            LANDSCAPE_META=$(echo "$LANDSCAPE_META" | jq ".[${NUM_TO_DELETE}:]")
          fi

          TOTAL_PORTRAIT=$(echo "$PORTRAIT_META" | jq 'length')
          if [ "$TOTAL_PORTRAIT" -gt "$MAX_FILES_PER_FOLDER" ]; then
            NUM_TO_DELETE=$((TOTAL_PORTRAIT - MAX_FILES_PER_FOLDER))
            echo "竖屏文件夹需要删除 ${NUM_TO_DELETE} 个最老的文件。"
            TO_DELETE=$(echo "$PORTRAIT_META" | jq -c ".[0:${NUM_TO_DELETE}] | .[]")
            while read -r meta_entry; do
              ID_TO_DELETE=$(echo "$meta_entry" | jq -r '.id')
              find assets/portrait -name "${ID_TO_DELETE}.*" -exec rm {} \;
              echo "已删除旧文件: ${ID_TO_DELETE}.*"
            done <<< "$TO_DELETE"
            PORTRAIT_META=$(echo "$PORTRAIT_META" | jq ".[${NUM_TO_DELETE}:]")
          fi

          # --- 写入元数据和索引文件 ---
          echo "正在写回最终的元数据和索引文件..."
          echo "$LANDSCAPE_META" | jq '{ "updated_at": "'$(date --iso-8601=seconds)'", "count": length, "data": . }' > assets/landscape/meta.json
          echo "$PORTRAIT_META"  | jq '{ "updated_at": "'$(date --iso-8601=seconds)'", "count": length, "data": . }' > assets/portrait/meta.json

          ls assets/landscape/ | jq -R . | jq -s . > assets/landscape/index.json
          ls assets/portrait/ | jq -R . | jq -s . > assets/portrait/index.json
          jq 'del(.[] | select(. == "index.json" or . == "meta.json"))' assets/landscape/index.json > tmp.$$.json && mv tmp.$$.json assets/landscape/index.json
          jq 'del(.[] | select(. == "index.json" or . == "meta.json"))' assets/portrait/index.json > tmp.$$.json && mv tmp.$$.json assets/portrait/index.json

      # <--- 变更点 2: 修改提交和推送的逻辑
      - name: Commit and Push new gallery
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add assets/
          # 检查是否有文件更改
          if [ -z "$(git status --porcelain)" ]; then
            echo "壁纸没有变化，无需推送。"
          else
            # 如果有更改，使用 --amend 来覆盖上一个提交。
            # 使用固定的提交信息，因为这个 commit 总是代表最新的画廊状态。
            # `|| git commit ...` 是一个备用逻辑，用于处理仓库中没有任何提交的初始情况。
            git commit --amend -m "feat(bot): Update wallpaper gallery to latest" || git commit -m "feat(bot): Initial wallpaper gallery"
            echo "覆盖提交成功，准备强制推送..."
            # 强制推送到远程仓库以更新历史
            git push --force
            echo "壁纸画廊已更新并强制推送至仓库。"
          fi