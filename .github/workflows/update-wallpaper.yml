# .github/workflows/update-wallpaper.yml

name: Update Wallpaper Gallery

on:
  schedule:
    # 每小时运行一次
    - cron: '0 * * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-gallery:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update Wallpaper Gallery
        id: update_gallery
        run: |
          # --- 配置 ---
          MAX_FILES_PER_FOLDER=100  # 每个文件夹最大文件数
          PAGES_TO_PROCESS=3        # 每次运行尝试处理的API页数
          DUPLICATE_THRESHOLD=0.7   # 当一页API数据中重复率超过70%时，跳过该页

          # --- 初始化 ---
          # 确保资产目录和元数据文件存在
          mkdir -p assets/landscape assets/portrait
          touch assets/landscape/meta.json assets/portrait/meta.json

          # 读取现有的所有壁纸ID，用于去重
          EXISTING_IDS=$(jq -s '.[0].data + .[1].data | .[] .id' assets/landscape/meta.json assets/portrait/meta.json)
          
          # --- 数据获取和过滤 ---
          echo "开始获取和过滤新的壁纸..."
          NEW_IMAGES_JSON="[]"
          MAX_ATTEMPTS=10 # API请求的最大尝试次数

          # 获取总页数
          LAST_PAGE=$(curl -s "https://wallhaven.cc/api/v1/search?q=anime+girls&categories=010&sorting=toplist&topRange=1M&purity=100" | jq '.meta.last_page')
          if [[ -z "$LAST_PAGE" || "$LAST_PAGE" == "null" || "$LAST_PAGE" -lt 1 ]]; then
            echo "错误：无法获取有效的总页数。跳过本次更新。"
            exit 0
          fi
          
          # 循环处理指定页数
          for i in $(seq 1 $PAGES_TO_PROCESS); do
            RANDOM_PAGE=$(( RANDOM % LAST_PAGE + 1 ))
            echo "正在处理第 ${i}/${PAGES_TO_PROCESS} 页 (API Page: ${RANDOM_PAGE})..."
          
            API_RESPONSE=$(curl -s "https://wallhaven.cc/api/v1/search?q=anime+girls&categories=010&sorting=toplist&topRange=1y&purity=100&page=${RANDOM_PAGE}")
            PAGE_IMAGES=$(echo "$API_RESPONSE" | jq -c '.data[]')
          
            if [[ -z "$PAGE_IMAGES" ]]; then
              echo "警告：API页面响应为空，尝试下一页。"
              sleep 1
              continue
            fi
          
            TOTAL_ON_PAGE=$(echo "$PAGE_IMAGES" | wc -l)
            DUPLICATES_ON_PAGE=0
            FRESH_IMAGES_ON_PAGE="[]"

            # 检查当前页的重复率
            while read -r image_json; do
              IMAGE_ID=$(echo "$image_json" | jq -r '.id')
              if echo "$EXISTING_IDS" | grep -q "\"$IMAGE_ID\""; then
                DUPLICATES_ON_PAGE=$((DUPLICATES_ON_PAGE + 1))
              else
                FRESH_IMAGES_ON_PAGE=$(echo "$FRESH_IMAGES_ON_PAGE" | jq --argjson img "$image_json" '. + [$img]')
              fi
            done <<< "$PAGE_IMAGES"

            DUPLICATE_RATE=$(echo "scale=2; $DUPLICATES_ON_PAGE / $TOTAL_ON_PAGE" | bc)
            if (( $(echo "$DUPLICATE_RATE > $DUPLICATE_THRESHOLD" | bc -l) )); then
              echo "警告：重复率 (${DUPLICATE_RATE}) 过高，放弃处理此页。"
              continue
            fi

            # 将本页所有新的、非重复的图片添加到主列表
            NEW_IMAGES_JSON=$(echo "$NEW_IMAGES_JSON" | jq --argjson fresh "$FRESH_IMAGES_ON_PAGE" '. + $fresh')
            echo "从本页成功添加 $(echo "$FRESH_IMAGES_ON_PAGE" | jq 'length') 张新图。"
          done

          if [[ $(echo "$NEW_IMAGES_JSON" | jq 'length') -eq 0 ]]; then
            echo "经过筛选，没有发现任何新的壁纸，本次任务结束。"
            exit 0
          fi
          
          # --- 处理、排序和下载 ---
          echo "开始处理和下载 $(echo "$NEW_IMAGES_JSON" | jq 'length') 张新壁纸..."
          # 读取最新的元数据
          LANDSCAPE_META=$(jq '.data' assets/landscape/meta.json)
          PORTRAIT_META=$(jq '.data' assets/portrait/meta.json)

          # 下载新图片并更新元数据列表
          while read -r image_json; do
            ID=$(echo "$image_json" | jq -r '.id')
            PATH_URL=$(echo "$image_json" | jq -r '.path')
            SOURCE_URL=$(echo "$image_json" | jq -r '.source')
            RATIO=$(echo "$image_json" | jq -r '.ratio | tonumber')
            EXTENSION="${PATH_URL##*.}"
            FILENAME="${ID}.${EXTENSION}"
            TIMESTAMP=$(date --iso-8601=seconds)

            NEW_META_ENTRY=$(jq -n --arg id "$ID" --arg source "$SOURCE_URL" --arg ts "$TIMESTAMP" \
              '{id: $id, source: $source, added_at: $ts}')

            if (( $(echo "$RATIO >= 1.0" | bc -l) )); then
              echo "下载横屏图片: ${FILENAME}"
              curl -s -L -o "assets/landscape/${FILENAME}" "$PATH_URL"
              LANDSCAPE_META=$(echo "$LANDSCAPE_META" | jq --argjson entry "$NEW_META_ENTRY" '. + [$entry]')
            else
              echo "下载竖屏图片: ${FILENAME}"
              curl -s -L -o "assets/portrait/${FILENAME}" "$PATH_URL"
              PORTRAIT_META=$(echo "$PORTRAIT_META" | jq --argjson entry "$NEW_META_ENTRY" '. + [$entry]')
            fi
          done < <(echo "$NEW_IMAGES_JSON" | jq -c '.[]')

          # --- 清理旧文件 (FIFO) ---
          echo "开始清理旧文件以维持数量上限..."
          # 清理横屏文件夹
          TOTAL_LANDSCAPE=$(echo "$LANDSCAPE_META" | jq 'length')
          if [ "$TOTAL_LANDSCAPE" -gt "$MAX_FILES_PER_FOLDER" ]; then
            NUM_TO_DELETE=$((TOTAL_LANDSCAPE - MAX_FILES_PER_FOLDER))
            echo "横屏文件夹需要删除 ${NUM_TO_DELETE} 个最老的文件。"
            TO_DELETE=$(echo "$LANDSCAPE_META" | jq -c ".[0:${NUM_TO_DELETE}] | .[]")
            while read -r meta_entry; do
              ID_TO_DELETE=$(echo "$meta_entry" | jq -r '.id')
              find assets/landscape -name "${ID_TO_DELETE}.*" -exec rm {} \;
              echo "已删除旧文件: ${ID_TO_DELETE}.*"
            done <<< "$TO_DELETE"
            LANDSCAPE_META=$(echo "$LANDSCAPE_META" | jq ".[${NUM_TO_DELETE}:]")
          fi

          # 清理竖屏文件夹
          TOTAL_PORTRAIT=$(echo "$PORTRAIT_META" | jq 'length')
          if [ "$TOTAL_PORTRAIT" -gt "$MAX_FILES_PER_FOLDER" ]; then
            NUM_TO_DELETE=$((TOTAL_PORTRAIT - MAX_FILES_PER_FOLDER))
            echo "竖屏文件夹需要删除 ${NUM_TO_DELETE} 个最老的文件。"
            TO_DELETE=$(echo "$PORTRAIT_META" | jq -c ".[0:${NUM_TO_DELETE}] | .[]")
            while read -r meta_entry; do
              ID_TO_DELETE=$(echo "$meta_entry" | jq -r '.id')
              find assets/portrait -name "${ID_TO_DELETE}.*" -exec rm {} \;
              echo "已删除旧文件: ${ID_TO_DELETE}.*"
            done <<< "$TO_DELETE"
            PORTRAIT_META=$(echo "$PORTRAIT_META" | jq ".[${NUM_TO_DELETE}:]")
          fi

          # --- 写入元数据和索引文件 ---
          echo "正在写回最终的元数据和索引文件..."
          echo "$LANDSCAPE_META" | jq '{ "updated_at": "'$(date --iso-8601=seconds)'", "count": length, "data": . }' > assets/landscape/meta.json
          echo "$PORTRAIT_META"  | jq '{ "updated_at": "'$(date --iso-8601=seconds)'", "count": length, "data": . }' > assets/portrait/meta.json

          # (可选) 为了兼容，重新生成只包含文件名的 index.json
          # 使用 ls 命令列出所有文件，然后用 jq 格式化成 JSON 数组，比复杂的解析更可靠
          ls assets/landscape/ | jq -R . | jq -s . > assets/landscape/index.json
          ls assets/portrait/ | jq -R . | jq -s . > assets/portrait/index.json
          # 从生成的列表中移除 meta.json 和 index.json 自身
          jq 'del(.[] | select(. == "index.json" or . == "meta.json"))' assets/landscape/index.json > tmp.$$.json && mv tmp.$$.json assets/landscape/index.json
          jq 'del(.[] | select(. == "index.json" or . == "meta.json"))' assets/portrait/index.json > tmp.$$.json && mv tmp.$$.json assets/portrait/index.json

      - name: Commit and Push new gallery
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add assets/
          if [ -n "$(git status --porcelain)" ]; then
            git commit -m "feat(bot): Update wallpaper gallery, add new and remove old"
            git push
            echo "壁纸画廊已更新并推送至仓库。"
          else
            echo "壁纸没有变化，无需推送。"
          fi